'use client';

import React, { useState, useEffect, useRef, useCallback } from 'react';

interface CalibrationPoint {
  gazeX: number;
  gazeY: number;
  screenX: number;
  screenY: number;
}

interface CalibrationMatrix {
  a: number;
  b: number;
  c: number;
  d: number;
  tx: number;
  ty: number;
}

interface Position {
  x: number;
  y: number;
}

interface GazeRatio {
  x: number;
  y: number;
}

interface EyeBounds {
  outer?: { x: number; y: number };
  inner?: { x: number; y: number };
  top?: { x: number; y: number };
  bottom?: { x: number; y: number };
}

interface Landmark {
  x: number;
  y: number;
  z?: number;
}

interface FaceMeshResults {
  multiFaceLandmarks?: Landmark[][];
}

// FaceMesh Ïù∏Ïä§ÌÑ¥Ïä§ ÌÉÄÏûÖ Ï†ïÏùò
interface FaceMeshInstance {
  setOptions: (options: {
    maxNumFaces: number;
    refineLandmarks: boolean;
    minDetectionConfidence: number;
    minTrackingConfidence: number;
  }) => void;
  onResults: (callback: (results: FaceMeshResults) => void) => void;
  send: (data: { image: HTMLVideoElement }) => Promise<void>;
}

declare global {
  interface Window {
    FaceMesh: new (config: {
      locateFile: (file: string) => string;
    }) => FaceMeshInstance;
  }
}

const IrisTracker: React.FC = () => {
  const videoRef = useRef<HTMLVideoElement>(null);
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const gazeCursorRef = useRef<HTMLDivElement>(null);

  const [isModelLoaded, setIsModelLoaded] = useState(false);
  const [isTracking, setIsTracking] = useState(false);
  const [status, setStatus] = useState('‚è≥ MediaPipe Iris Î°úÎî© Ï§ë...');
  const [debugInfo, setDebugInfo] = useState('');
  const [eyeData, setEyeData] = useState('');
  const [sensitivity, setSensitivity] = useState(3.0);
  const [sensitivityY, setSensitivityY] = useState(4.0);
  const [calibrationMode, setCalibrationMode] = useState(false);
  const [calibrationStep, setCalibrationStep] = useState(0);
  const [calibrationPoints, setCalibrationPoints] = useState<CalibrationPoint[]>([]);
  const [calibrationMatrix, setCalibrationMatrix] = useState<CalibrationMatrix | null>(null);
  const [calibrationOffsets, setCalibrationOffsets] = useState<Position>({ x: 0, y: 0 });

  const faceMeshRef = useRef<FaceMeshInstance | null>(null);
  const streamRef = useRef<MediaStream | null>(null);
  const animationFrameRef = useRef<number | null>(null);
  const smoothedPositionRef = useRef<Position>({ x: 0, y: 0 });
  const lastGazeRatioRef = useRef<GazeRatio>({ x: 0.5, y: 0.5 });
  const smoothingFactor = 0.3;

  // MediaPipe Ïä§ÌÅ¨Î¶ΩÌä∏ Î°úÎî© (Iris Ìè¨Ìï®)
  const loadMediaPipeScripts = (): Promise<void> => {
    return new Promise((resolve, reject) => {
      if (typeof window !== 'undefined' && typeof window.FaceMesh !== 'undefined') {
        // // console.log('‚úÖ MediaPipe Ïù¥ÎØ∏ Î°úÎìúÎê®');
        resolve();
        return;
      }

      // // console.log('üì¶ MediaPipe Iris Ïä§ÌÅ¨Î¶ΩÌä∏ Î°úÎî© ÏãúÏûë...');
      const scripts = [
        'https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js',
        'https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js',
        'https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js',
        'https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js'
      ];

      let loadedCount = 0;

      scripts.forEach((src) => {
        const script = document.createElement('script');
        script.src = src;
        script.crossOrigin = 'anonymous';
        script.onload = () => {
          loadedCount++;
          // // console.log(`‚úÖ Ïä§ÌÅ¨Î¶ΩÌä∏ Î°úÎìú ÏôÑÎ£å (${loadedCount}/${scripts.length}): ${src.split('/').pop()}`);
          if (loadedCount === scripts.length) {
            // // console.log('üéâ Î™®Îì† MediaPipe Ïä§ÌÅ¨Î¶ΩÌä∏ Î°úÎìú ÏôÑÎ£å!');
            setTimeout(() => resolve(), 200);
          }
        };
        script.onerror = (e) => {
          console.error(`‚ùå Ïä§ÌÅ¨Î¶ΩÌä∏ Î°úÎìú Ïã§Ìå®: ${src}`, e);
          reject(e);
        };
        document.head.appendChild(script);
      });
    });
  };

  // ÎπÑÎîîÏò§ ÌîÑÎ†àÏûÑ Ï≤òÎ¶¨ Ìï®ÏàòÎ•º Î®ºÏ†Ä Ï†ïÏùò
  const processVideoFrame = useCallback(async () => {
    if (!isTracking || !faceMeshRef.current || !videoRef.current) {
      return;
    }

    try {
      if (videoRef.current.readyState >= 2 && faceMeshRef.current) {
        await faceMeshRef.current.send({ image: videoRef.current });
      }
    } catch (error) {
      console.error('üí• ÌîÑÎ†àÏûÑ Ï≤òÎ¶¨ Ïò§Î•ò:', error);
    }

    if (isTracking) {
      animationFrameRef.current = requestAnimationFrame(processVideoFrame);
    }
  }, [isTracking]);

  // isTracking ÏÉÅÌÉú Î≥ÄÌôî Ï∂îÏ†Å
  useEffect(() => {
    // // console.log('üîÑ isTracking ÏÉÅÌÉú:', isTracking);

    if (isTracking && faceMeshRef.current && videoRef.current) {
      // // console.log('üöÄ Iris Ï∂îÏ†Å Î£®ÌîÑ ÏãúÏûë!');
      processVideoFrame();
    } else if (!isTracking && animationFrameRef.current) {
      // // console.log('‚èπÔ∏è Iris Ï∂îÏ†Å Î£®ÌîÑ Ï†ïÏßÄ');
      cancelAnimationFrame(animationFrameRef.current);
    }
  }, [isTracking, processVideoFrame]);

  // MediaPipe Ï¥àÍ∏∞Ìôî (Iris Î™®Îìú)
  useEffect(() => {
    // Only run on client side
    if (typeof window === 'undefined') {
      return;
    }

    const initMediaPipe = async () => {
      try {
        // console.log('üé¨ MediaPipe Iris Ï¥àÍ∏∞Ìôî ÏãúÏûë...');
        await loadMediaPipeScripts();

        if (typeof window !== 'undefined' && typeof window.FaceMesh !== 'undefined') {
          // console.log('üîß FaceMesh Ïù∏Ïä§ÌÑ¥Ïä§ ÏÉùÏÑ± (Iris Î™®Îìú)...');

          const faceMesh = new window.FaceMesh({
            locateFile: (file: string) => {
              const url = `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`;
              // console.log(`üìÅ ÌååÏùº ÏöîÏ≤≠: ${url}`);
              return url;
            }
          });

          faceMesh.setOptions({
            maxNumFaces: 1,
            refineLandmarks: true,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
          });

          faceMesh.onResults(onFaceMeshResults);
          faceMeshRef.current = faceMesh;

          setIsModelLoaded(true);
          setStatus('‚úÖ MediaPipe Iris Ï§ÄÎπÑ ÏôÑÎ£å! Ïπ¥Î©îÎùºÎ•º ÏãúÏûëÌïòÏÑ∏Ïöî.');
          // console.log('üéâ MediaPipe Iris Ï¥àÍ∏∞Ìôî ÏôÑÎ£å!');
        } else {
          throw new Error('FaceMeshÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§');
        }
      } catch (error) {
        console.error('üí• MediaPipe Iris Ï¥àÍ∏∞Ìôî Ïã§Ìå®:', error);
        setStatus(`‚ùå MediaPipe Iris Ï¥àÍ∏∞Ìôî Ïã§Ìå®: ${(error as Error).message}`);
      }
    };

    initMediaPipe();

    return () => {
      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current);
      }
    };
  }, []);

  // MediaPipe Í≤∞Í≥º Ï≤òÎ¶¨ (Iris Ï†ÑÏö©)
  const onFaceMeshResults = useCallback((results: FaceMeshResults) => {
    // console.log('üìä MediaPipe Iris Í≤∞Í≥º Î∞õÏùå');

    if (!canvasRef.current) {
      // console.log('‚ùå Ï∫îÎ≤ÑÏä§ ÏóÜÏùå');
      return;
    }

    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    ctx.save();
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.scale(-1, 1);
    ctx.translate(-canvas.width, 0);

    if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
      const landmarks = results.multiFaceLandmarks[0];
      // console.log(`‚úÖ ÏñºÍµ¥ Í∞êÏßÄÎê®! ÎûúÎìúÎßàÌÅ¨ Í∞úÏàò: ${landmarks.length}`);

      drawIrisLandmarks(ctx, landmarks, canvas);
      calculateIrisGaze(landmarks);

      setDebugInfo(`Iris Ï∂îÏ†Å Ï§ë, ÎûúÎìúÎßàÌÅ¨: ${landmarks.length}Í∞ú`);

    } else {
      // console.log('‚ùå ÏñºÍµ¥ Í∞êÏßÄ ÏïàÎê®');
      setDebugInfo('ÏñºÍµ¥Ïù¥ Í∞êÏßÄÎêòÏßÄ ÏïäÏùå');
      setEyeData('Í∞êÏßÄ ÎåÄÍ∏∞ Ï§ë...');

      if (gazeCursorRef.current) {
        gazeCursorRef.current.style.display = 'none';
      }
    }

    ctx.restore();
  }, [isTracking, sensitivity, sensitivityY, calibrationOffsets, calibrationMatrix]);

  // Iris ÎûúÎìúÎßàÌÅ¨ Í∑∏Î¶¨Í∏∞
  const drawIrisLandmarks = (ctx: CanvasRenderingContext2D, landmarks: Landmark[], canvas: HTMLCanvasElement) => {
    const leftIrisIndices = [468, 469, 470, 471, 472];
    const rightIrisIndices = [473, 474, 475, 476, 477];

    const leftEyeOutline = [33, 7, 163, 144, 145, 153, 154, 155, 133, 173, 157, 158, 159, 160, 161, 246];
    const rightEyeOutline = [362, 382, 381, 380, 374, 373, 390, 249, 263, 466, 388, 387, 386, 385, 384, 398];

    ctx.strokeStyle = 'rgba(0, 255, 0, 0.3)';
    ctx.lineWidth = 1;

    ctx.beginPath();
    leftEyeOutline.forEach((index, i) => {
      if (landmarks[index]) {
        const point = landmarks[index];
        const x = point.x * canvas.width;
        const y = point.y * canvas.height;
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
    });
    ctx.closePath();
    ctx.stroke();

    ctx.beginPath();
    rightEyeOutline.forEach((index, i) => {
      if (landmarks[index]) {
        const point = landmarks[index];
        const x = point.x * canvas.width;
        const y = point.y * canvas.height;
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
    });
    ctx.closePath();
    ctx.stroke();

    ctx.fillStyle = '#ff0000';

    leftIrisIndices.forEach(index => {
      if (landmarks[index]) {
        const point = landmarks[index];
        ctx.beginPath();
        ctx.arc(point.x * canvas.width, point.y * canvas.height, 2, 0, 2 * Math.PI);
        ctx.fill();
      }
    });

    rightIrisIndices.forEach(index => {
      if (landmarks[index]) {
        const point = landmarks[index];
        ctx.beginPath();
        ctx.arc(point.x * canvas.width, point.y * canvas.height, 2, 0, 2 * Math.PI);
        ctx.fill();
      }
    });

    ctx.fillStyle = '#00ff00';
    const leftIrisCenter = getIrisCenter(landmarks, leftIrisIndices);
    const rightIrisCenter = getIrisCenter(landmarks, rightIrisIndices);

    if (leftIrisCenter) {
      ctx.beginPath();
      ctx.arc(leftIrisCenter.x * canvas.width, leftIrisCenter.y * canvas.height, 4, 0, 2 * Math.PI);
      ctx.fill();
    }

    if (rightIrisCenter) {
      ctx.beginPath();
      ctx.arc(rightIrisCenter.x * canvas.width, rightIrisCenter.y * canvas.height, 4, 0, 2 * Math.PI);
      ctx.fill();
    }
  };

  // Iris Ï§ëÏã¨Ï†ê Í≥ÑÏÇ∞
  const getIrisCenter = (landmarks: Landmark[], irisIndices: number[]): Position | null => {
    let sumX = 0, sumY = 0, count = 0;

    irisIndices.forEach(index => {
      if (landmarks[index]) {
        sumX += landmarks[index].x;
        sumY += landmarks[index].y;
        count++;
      }
    });

    if (count === 0) return null;

    return {
      x: sumX / count,
      y: sumY / count
    };
  };

  // Iris Í∏∞Î∞ò ÏãúÏÑ† Ï∂îÏ†Å Í≥ÑÏÇ∞
  const calculateIrisGaze = (landmarks: Landmark[]) => {
    try {
      // console.log('üëÅÔ∏è Iris Í∏∞Î∞ò ÏãúÏÑ† Í≥ÑÏÇ∞ ÏãúÏûë...');

      const leftIrisCenter = getIrisCenter(landmarks, [468, 469, 470, 471, 472]);
      const rightIrisCenter = getIrisCenter(landmarks, [473, 474, 475, 476, 477]);

      if (!leftIrisCenter || !rightIrisCenter) {
        // console.log('‚ùå Iris Ï§ëÏã¨Ï†ê Í∞êÏßÄ Ïã§Ìå®');
        return;
      }

      // console.log('üîç ÏôºÏ™Ω Iris Ï§ëÏã¨:', leftIrisCenter);
      // console.log('üîç Ïò§Î•∏Ï™Ω Iris Ï§ëÏã¨:', rightIrisCenter);

      const leftEyeBounds: EyeBounds = {
        outer: landmarks[33],
        inner: landmarks[133],
        top: landmarks[159],
        bottom: landmarks[145]
      };

      const rightEyeBounds: EyeBounds = {
        outer: landmarks[263],
        inner: landmarks[362],
        top: landmarks[386],
        bottom: landmarks[374]
      };

      const leftGazeRatio = calculateIrisRatio(leftIrisCenter, leftEyeBounds);
      const rightGazeRatio = calculateIrisRatio(rightIrisCenter, rightEyeBounds);

      // console.log('üìä ÏôºÏ™Ω Iris ÎπÑÏú®:', leftGazeRatio);
      // console.log('üìä Ïò§Î•∏Ï™Ω Iris ÎπÑÏú®:', rightGazeRatio);

      const avgGazeRatio: GazeRatio = {
        x: (leftGazeRatio.x + rightGazeRatio.x) / 2,
        y: (leftGazeRatio.y + rightGazeRatio.y) / 2
      };

      lastGazeRatioRef.current = { x: avgGazeRatio.x, y: avgGazeRatio.y };

      // console.log('üéØ ÌèâÍ∑† Iris ÎπÑÏú®:', avgGazeRatio);

      let screenX: number, screenY: number;

      if (calibrationMatrix) {
        const { a, b, c, d, tx, ty } = calibrationMatrix;
        screenX = a * avgGazeRatio.x + b * avgGazeRatio.y + tx;
        screenY = c * avgGazeRatio.x + d * avgGazeRatio.y + ty;
        // console.log('üéØ Í≥†Í∏â Ï∫òÎ¶¨Î∏åÎ†àÏù¥ÏÖò Ï†ÅÏö©:', { screenX, screenY });
      } else {
        const normalizedX = 1 - avgGazeRatio.x;
        const normalizedY = avgGazeRatio.y;

        const adjustedX = normalizedX + calibrationOffsets.x;
        const adjustedY = normalizedY + calibrationOffsets.y;

        screenX = window.innerWidth * ((adjustedX - 0.5) * sensitivity + 0.5);
        screenY = window.innerHeight * ((adjustedY - 0.5) * sensitivityY + 0.5);
      }

      // console.log('üñ•Ô∏è Í≥ÑÏÇ∞Îêú ÌôîÎ©¥ Ï¢åÌëú:', { screenX, screenY });

      const boundedX = Math.max(30, Math.min(window.innerWidth - 30, screenX));
      const boundedY = Math.max(30, Math.min(window.innerHeight - 30, screenY));

      updateGazeCursor({ x: boundedX, y: boundedY });

      setEyeData(`L:(${leftGazeRatio.x.toFixed(2)},${leftGazeRatio.y.toFixed(2)}) R:(${rightGazeRatio.x.toFixed(2)},${rightGazeRatio.y.toFixed(2)}) ÌèâÍ∑†:(${avgGazeRatio.x.toFixed(2)},${avgGazeRatio.y.toFixed(2)})`);

    } catch (error) {
      console.error('üí• Iris ÏãúÏÑ† Í≥ÑÏÇ∞ Ïò§Î•ò:', error);
      setDebugInfo(`Iris Í≥ÑÏÇ∞ Ïò§Î•ò: ${(error as Error).message}`);
    }
  };

  // Iris ÏúÑÏπò ÎπÑÏú® Í≥ÑÏÇ∞
  const calculateIrisRatio = (irisCenter: Position, eyeBounds: EyeBounds): GazeRatio => {
    if (!irisCenter || !eyeBounds.outer || !eyeBounds.inner) {
      return { x: 0.5, y: 0.5 };
    }

    const eyeWidth = Math.abs(eyeBounds.outer.x - eyeBounds.inner.x);
    const eyeHeight = eyeBounds.top && eyeBounds.bottom ?
      Math.abs(eyeBounds.top.y - eyeBounds.bottom.y) : eyeWidth * 0.5;

    const eyeCenterX = (eyeBounds.outer.x + eyeBounds.inner.x) / 2;
    const eyeCenterY = eyeBounds.top && eyeBounds.bottom ?
      (eyeBounds.top.y + eyeBounds.bottom.y) / 2 : irisCenter.y;

    let ratioX = 0.5 + (irisCenter.x - eyeCenterX) / (eyeWidth * 0.8);
    let ratioY = 0.5 + (irisCenter.y - eyeCenterY) / (eyeHeight * 0.8);

    ratioX = Math.max(0.1, Math.min(0.9, ratioX));
    ratioY = Math.max(0.1, Math.min(0.9, ratioY));

    return { x: ratioX, y: ratioY };
  };

  // Ïª§ÏÑú ÏóÖÎç∞Ïù¥Ìä∏ (ÌôîÎ©¥ ÌïòÎã® Ï†àÎ∞òÏúºÎ°ú Ï†úÌïú)
  const updateGazeCursor = (position: Position) => {
    if (!gazeCursorRef.current) return;

    // Y Ï¢åÌëúÎ•º ÌôîÎ©¥ ÌïòÎã® Ï†àÎ∞òÏúºÎ°ú Ï†úÌïú
    const minY = window.innerHeight / 2;
    const maxY = window.innerHeight - 30;
    const constrainedY = Math.max(minY, Math.min(maxY, position.y));

    // X Ï¢åÌëúÎäî Ï†ÑÏ≤¥ Î≤îÏúÑ ÏÇ¨Ïö©
    const constrainedX = Math.max(30, Math.min(window.innerWidth - 30, position.x));

    if (smoothedPositionRef.current.x === 0 && smoothedPositionRef.current.y === 0) {
      smoothedPositionRef.current = { x: constrainedX, y: constrainedY };
    }

    smoothedPositionRef.current.x += (constrainedX - smoothedPositionRef.current.x) * smoothingFactor;
    smoothedPositionRef.current.y += (constrainedY - smoothedPositionRef.current.y) * smoothingFactor;

    gazeCursorRef.current.style.left = smoothedPositionRef.current.x + 'px';
    gazeCursorRef.current.style.top = smoothedPositionRef.current.y + 'px';
    gazeCursorRef.current.style.display = 'block';
    gazeCursorRef.current.style.visibility = 'visible';
    gazeCursorRef.current.style.opacity = '1';
  };


  // Ïπ¥Î©îÎùº ÏãúÏûë
  const startCamera = async () => {
    try {
      // console.log('üé¨ Iris Ï∂îÏ†Å Ïπ¥Î©îÎùº ÏãúÏûë...');
      setStatus('üìπ Ïπ¥Î©îÎùº Ïó∞Í≤∞ Ï§ë...');

      const stream = await navigator.mediaDevices.getUserMedia({
        video: {
          width: 640,
          height: 480,
          facingMode: 'user'
        }
      });

      // console.log('‚úÖ ÎπÑÎîîÏò§ Ïä§Ìä∏Î¶º ÌöçÎìù');

      if (videoRef.current) {
        videoRef.current.srcObject = stream;
        streamRef.current = stream;

        videoRef.current.onloadedmetadata = () => {
          // console.log('üéØ ÎπÑÎîîÏò§ Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ Î°úÎìú ÏôÑÎ£å');
          videoRef.current?.play(); // ÎπÑÎîîÏò§ Ïû¨ÏÉù ÏãúÏûë
          setIsTracking(true);
          setStatus('üëÅÔ∏è Iris Ï∂îÏ†Å Ï§ë...');
        };
      }

    } catch (error) {
      console.error('üí• Ïπ¥Î©îÎùº ÏãúÏûë Ïã§Ìå®:', error);
      setStatus(`‚ùå Ïπ¥Î©îÎùº Ïò§Î•ò: ${(error as Error).message}`);
    }
  };

  // Ïª¥Ìè¨ÎÑåÌä∏ ÎßàÏö¥Ìä∏ Ïãú ÏûêÎèôÏúºÎ°ú Ïπ¥Î©îÎùº ÏãúÏûë
  useEffect(() => {
    if (isModelLoaded && !isTracking) {
      // console.log('üöÄ ÏûêÎèôÏúºÎ°ú Ïπ¥Î©îÎùº ÏãúÏûë...');
      startCamera();
    }
  }, [isModelLoaded]);

  // Ïπ¥Î©îÎùº Ï†ïÏßÄ
  const stopCamera = () => {
    // console.log('üõë Iris Ï∂îÏ†Å Ïπ¥Î©îÎùº Ï†ïÏßÄ');
    setIsTracking(false);

    if (streamRef.current) {
      streamRef.current.getTracks().forEach(track => track.stop());
      streamRef.current = null;
    }

    if (videoRef.current) {
      videoRef.current.srcObject = null;
    }

    if (gazeCursorRef.current) {
      gazeCursorRef.current.style.display = 'none';
    }

    setStatus('‚èπÔ∏è Ïπ¥Î©îÎùº Ï†ïÏßÄÎê®');
    setDebugInfo('');
    setEyeData('');
  };

  // Í∞ÑÎã®Ìïú Ï∫òÎ¶¨Î∏åÎ†àÏù¥ÏÖò
  const quickCalibrate = () => {
    if (!isTracking) {
      alert('Î®ºÏ†Ä ÏãúÏÑ† Ï∂îÏ†ÅÏùÑ ÏãúÏûëÌï¥Ï£ºÏÑ∏Ïöî.');
      return;
    }

    const centerX = window.innerWidth / 2;
    const centerY = window.innerHeight / 2;

    const currentX = parseFloat(gazeCursorRef.current?.style.left || '0');
    const currentY = parseFloat(gazeCursorRef.current?.style.top || '0');
    // console.log('üéØ ÌòÑÏû¨ Ïª§ÏÑú ÏúÑÏπò:', { currentX, currentY });

    const offsetX = (centerX - currentX) / window.innerWidth * 0.5;
    const offsetY = (centerY - currentY) / window.innerHeight * 0.5;

    setCalibrationOffsets({ x: offsetX, y: offsetY });
    setDebugInfo(`Ï∫òÎ¶¨Î∏åÎ†àÏù¥ÏÖò ÏôÑÎ£å! Ïò§ÌîÑÏÖã: (${offsetX.toFixed(3)}, ${offsetY.toFixed(3)})`);
    // console.log('üéØ Ï∫òÎ¶¨Î∏åÎ†àÏù¥ÏÖò ÏôÑÎ£å:', { offsetX, offsetY });
  };

  // 5Ï†ê Ï∫òÎ¶¨Î∏åÎ†àÏù¥ÏÖò ÏãúÏûë
  const startAdvancedCalibration = () => {
    if (!isTracking) {
      alert('Î®ºÏ†Ä ÏãúÏÑ† Ï∂îÏ†ÅÏùÑ ÏãúÏûëÌï¥Ï£ºÏÑ∏Ïöî.');
      return;
    }

    setCalibrationMode(true);
    setCalibrationStep(1);
    setCalibrationPoints([]);
    setCalibrationMatrix(null);
    setDebugInfo('üéØ 5Ï†ê Ï∫òÎ¶¨Î∏åÎ†àÏù¥ÏÖò ÏãúÏûë! Îπ®Í∞Ñ Ï†êÏùÑ Î∞îÎùºÎ≥¥Í≥† ÌÅ¥Î¶≠ÌïòÏÑ∏Ïöî (1/5)');
    // console.log('üéØ 5Ï†ê Ï∫òÎ¶¨Î∏åÎ†àÏù¥ÏÖò ÏãúÏûë');
  };

  // Ï∫òÎ¶¨Î∏åÎ†àÏù¥ÏÖò Ï†ê ÏàòÏßë
  const collectCalibrationPoint = () => {
    if (!calibrationMode || !gazeCursorRef.current) return;

    const currentGazeRatio = lastGazeRatioRef.current;
    if (!currentGazeRatio) {
      alert('ÌôçÏ±ÑÎ•º Í∞êÏßÄÌï† Ïàò ÏóÜÏäµÎãàÎã§. Ïπ¥Î©îÎùºÎ•º ÌôïÏù∏Ìï¥Ï£ºÏÑ∏Ïöî.');
      return;
    }

    const targetPoints = [
      { x: window.innerWidth * 0.5, y: window.innerHeight * 0.5 },
      { x: window.innerWidth * 0.2, y: window.innerHeight * 0.2 },
      { x: window.innerWidth * 0.8, y: window.innerHeight * 0.2 },
      { x: window.innerWidth * 0.2, y: window.innerHeight * 0.8 },
      { x: window.innerWidth * 0.8, y: window.innerHeight * 0.8 }
    ];

    const target = targetPoints[calibrationStep - 1];
    const point: CalibrationPoint = {
      gazeX: currentGazeRatio.x,
      gazeY: currentGazeRatio.y,
      screenX: target.x,
      screenY: target.y
    };

    const newPoints = [...calibrationPoints, point];
    setCalibrationPoints(newPoints);

    // console.log(`‚úÖ Ï∫òÎ¶¨Î∏åÎ†àÏù¥ÏÖò Ï†ê ${calibrationStep}/5 ÏàòÏßë:`, point);

    if (calibrationStep < 5) {
      setCalibrationStep(calibrationStep + 1);
      setDebugInfo(`üéØ Ï∫òÎ¶¨Î∏åÎ†àÏù¥ÏÖò ÏßÑÌñâ Ï§ë... Îã§Ïùå Îπ®Í∞Ñ Ï†êÏùÑ Î∞îÎùºÎ≥¥Í≥† ÌÅ¥Î¶≠ÌïòÏÑ∏Ïöî (${calibrationStep + 1}/5)`);
    } else {
      const matrix = calculateTransformMatrix(newPoints);
      setCalibrationMatrix(matrix);
      setCalibrationMode(false);
      setCalibrationStep(0);
      setDebugInfo('üéâ 5Ï†ê Ï∫òÎ¶¨Î∏åÎ†àÏù¥ÏÖò ÏôÑÎ£å! Í≥†Ï†ïÎ∞Ä ÏãúÏÑ† Ï∂îÏ†ÅÏù¥ ÌôúÏÑ±ÌôîÎêòÏóàÏäµÎãàÎã§.');
      // console.log('üéâ 5Ï†ê Ï∫òÎ¶¨Î∏åÎ†àÏù¥ÏÖò ÏôÑÎ£å, Î≥ÄÌôò ÌñâÎ†¨:', matrix);
    }
  };

  // Î≥ÄÌôò ÌñâÎ†¨ Í≥ÑÏÇ∞
  const calculateTransformMatrix = (points: CalibrationPoint[]): CalibrationMatrix | null => {
    if (points.length < 3) return null;

    let sumGx = 0, sumGy = 0, sumSx = 0, sumSy = 0;
    let sumGxSx = 0, sumGySx = 0, sumGxSy = 0, sumGySy = 0;
    let sumGxGx = 0, sumGyGy = 0;
    const n = points.length;

    points.forEach(p => {
      sumGx += p.gazeX;
      sumGy += p.gazeY;
      sumSx += p.screenX;
      sumSy += p.screenY;
      sumGxSx += p.gazeX * p.screenX;
      sumGySx += p.gazeY * p.screenX;
      sumGxSy += p.gazeX * p.screenY;
      sumGySy += p.gazeY * p.screenY;
      sumGxGx += p.gazeX * p.gazeX;
      sumGyGy += p.gazeY * p.gazeY;
    });

    const a = (n * sumGxSx - sumGx * sumSx) / (n * sumGxGx - sumGx * sumGx);
    const b = (n * sumGySx - sumGy * sumSx) / (n * sumGyGy - sumGy * sumGy);
    const tx = (sumSx - a * sumGx - b * sumGy) / n;

    const c = (n * sumGxSy - sumGx * sumSy) / (n * sumGxGx - sumGx * sumGx);
    const d = (n * sumGySy - sumGy * sumSy) / (n * sumGyGy - sumGy * sumGy);
    const ty = (sumSy - c * sumGx - d * sumGy) / n;

    return { a, b, c, d, tx, ty };
  };

  // Ï∫òÎ¶¨Î∏åÎ†àÏù¥ÏÖò Î¶¨ÏÖã
  const resetCalibration = () => {
    setCalibrationOffsets({ x: 0, y: 0 });
    setCalibrationMode(false);
    setCalibrationStep(0);
    setCalibrationPoints([]);
    setCalibrationMatrix(null);
    setDebugInfo('üîÑ Î™®Îì† Ï∫òÎ¶¨Î∏åÎ†àÏù¥ÏÖò Î¶¨ÏÖãÎê®');
    // console.log('üîÑ Ï∫òÎ¶¨Î∏åÎ†àÏù¥ÏÖò Î¶¨ÏÖã');
  };

  // ÌÖåÏä§Ìä∏ Ïª§ÏÑú
  const showTestCursor = () => {
    if (gazeCursorRef.current) {
      const element = gazeCursorRef.current;

      element.style.display = 'block';
      element.style.visibility = 'visible';
      element.style.opacity = '1';
      element.style.left = (window.innerWidth / 2) + 'px';
      element.style.top = (window.innerHeight / 2) + 'px';
      element.style.transform = 'translate(-50%, -50%)';
      element.style.zIndex = '99999';
      element.style.position = 'fixed';
      element.style.pointerEvents = 'none';

      element.style.width = '30px';
      element.style.height = '30px';
      element.style.backgroundColor = '#ff0000';
      element.style.border = '5px solid white';
      element.style.borderRadius = '50%';
      element.style.boxShadow = '0 0 20px rgba(255, 0, 0, 1)';

      setDebugInfo('üî¥ Í∞ïÌôîÎêú ÌÖåÏä§Ìä∏ Ïª§ÏÑú ÌëúÏãúÎê® - Îπ®Í∞Ñ ÏõêÏù¥ ÌôîÎ©¥ Ï§ëÏïôÏóê Î≥¥Ïù¥ÏãúÎÇòÏöî?');
    }
  };

  return (
    <>
      {/* Ïà®Í≤®ÏßÑ ÎπÑÎîîÏò§ÏôÄ Ï∫îÎ≤ÑÏä§ (ÌôîÎ©¥Ïóê ÌëúÏãúÎêòÏßÄ ÏïäÏùå) */}
      <div className="fixed top-0 left-0 opacity-0 pointer-events-none" style={{ width: 0, height: 0, overflow: 'hidden' }}>
        <video
          ref={videoRef}
          autoPlay
          muted
          playsInline
          width={640}
          height={480}
        />
        <canvas
          ref={canvasRef}
          width={640}
          height={480}
        />
      </div>

      {/* ÏãúÏÑ† Ï∂îÏ†Å Îπ®Í∞Ñ Ï†ê Ïª§ÏÑú */}
      <div
        id="gaze-tracking-cursor"
        ref={gazeCursorRef}
        className="fixed pointer-events-none"
        style={{
          width: '20px',
          height: '20px',
          backgroundColor: '#ff0000',
          borderRadius: '50%',
          border: '3px solid rgba(255, 255, 255, 0.9)',
          boxShadow: `
            0 0 20px rgba(255, 0, 0, 1),
            0 0 40px rgba(255, 0, 0, 0.6),
            inset 0 0 8px rgba(255, 255, 255, 0.7)
          `,
          zIndex: 999999,
          display: 'none',
          transform: 'translate(-50%, -50%)',
          transition: 'all 0.08s ease-out',
        }}
      >
        <div
          className="absolute inset-1 bg-white rounded-full opacity-70"
          style={{ animation: 'pulseAnimation 1.5s ease-in-out infinite' }}
        />
      </div>

      <style dangerouslySetInnerHTML={{
        __html: `
          @keyframes pulseAnimation {
            0%, 100% { opacity: 0.7; transform: scale(1); }
            50% { opacity: 0.3; transform: scale(0.8); }
          }
        `
      }} />
    </>
  );
};

export default IrisTracker;
